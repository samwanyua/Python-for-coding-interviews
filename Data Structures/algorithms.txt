Search algorithms:
* Binary search
- time complexity: O(log n)

* DFS (depth first search)
- DFS explores the graph by going as deep as possible along each branch before backtracking.
- Real life application: solving a maze
- time complexity: O(v + e) # where v are vertices/nodes and e= edges/branches

* BFS(Breadth first search)
- Application: chess algorithm
- BFS explores the graph level by level, starting from a given node,
 and visits all neighbors at the present depth before moving on to nodes at the next depth level.
- time complexity: O(v + e) # where v are vertices/nodes and e= edges/branches

Sorting algorithms
* Insertion sort
- Best case: O(n) # when everything is sorted
- Worst case: O(n^2) # when nothing is sorted
- Best for when lists are already sorted or small

* Merge sort
- Follows divide and conquer algorithm
- It's a recursive algorithm
- Time complexity - O(n log n)
- Space complexity: O(n)

* Quick sort
- Best case: O(n log n)
- Worst case: O(n^2)
- space complexity: O(log n)



